java简介
1.java是SUN公司开发的高级编程语言，常用与互联网软件开发。
	（1）桌面软件开发，如ecli
	（2）网络后台开发，如腾讯
	（3）手机APP开发，如安卓手机
	（4）动态网页开发，如jsp
	（5）大数据/分布式
	（6）部分游戏开发

2.java特性
	（1）跨平台性
JVM:java虚拟机，在不同的操作系统中，需要安装对应版本虚拟机，jvm
	会将java程序代码翻译成当前操作系统可以识别的指令去运行。
	注意：所用代码运行在jvm虚拟机中
JRE:java运行时环境
JDK:java开发工具包，用于开发者配置环境，包括java源码包‘各类开发工具以及jre运行时环境

3.环境变量配置
	JAVA_HOME 代表java中jdk安装根目录
	path：%JAVA_HOME%\bin
	
4.java程序执行
	（1）创建.java文件
	（2）在源文件中编写代码
	（3）在cmd命令行输入javac +文件名.java编译源文件，然后输入java +文件名运行程序；注意：要切换到源文件所在路径

Day1015
1.包名取名规则
	com.rimi.project.hello
	包名有多个单词组成，单词用.隔开；
	第一个单词，推荐代表当前目录所具备的限制性意义或性质 例如：com表示盈利性机构
	第二个单词，推荐公司名或者组织名
	其他单词，用来描述项目结构
2.命名规则
	关键字：java语言对部分单词提前用来做了系统功能的使用，其他地方不能再使用
		注意：关键字的单词必须小写
	标识符：开发者自定义的名字，所有关键字不能用来当作标识符
		标识符只能使用，大小写字母，数字_和$
	包名：全部小写
		类名或接口名：
				大驼峰原则：多个单词直接拼接在一起，每个单词首字母大写
				注意：必须和文件名保持一致
		方法名和变量名：首字母小写的驼峰原则
		常量名：只定义一次，以后不改变值
			XXX_YYY_ZZZ 全部使用大写字母，多个单词用_隔开
			java中的命名规则是独一无二的，切忌使用以下方法
			int i，j，k；
			java中严格区分大小写
			java标识符不能以数字开头
3.  6种常量类型
	整数型 默认整数常量为10进制  二进制，以0b或者0B开头   八进制，以0开头   十六进制，以0x或者0X开头  
	小数型、
	布尔型  true或false 
	字符型  用''包裹
	字符串	用""包裹
	null 没有任何值的常量，表示的含义为空，常用与面向对象，不能被打印
	整数常量默认为int；小数常量默认为double；
4.变量
	是一个可以改变值的量，在内存空间中开辟一块空间将值临时保存，方便以后对这个值进行使用
	类型： 
	在计算机中，所有数据都用二进制形式表示，连续8个0/1 二进制，叫做一个字节byte
	超出当前数据类型可以表示的数据范围，编译时会报错
		基本数据类型：关键字		字节数		无符号表示范围		有符号表示范围
			整数型：
						byte 			1字节		    0 - 255			-128-127
						short 			2字节			0-65535			-32768 - 32767
						int 			4字节			0-2^32-1		-2^31 - 2^31-1
						long			8字节			0-2^64-1		-2^63 - 2^63-1
			java默认情况下，所有整数型均为有符号整数，用第一位二进制表示正负号
			浮点型：float	4字节
					double	8字节
					小数点后面位数太长用double；
			字符型：char
			布尔型：boolean
	
	变量声明的语法：
		指定变量的数据类型  给定的变量名；
	数据类型转换：
		大的数据类型赋值给小的数据类型，很容易造成数据丢失，编译时会报错
		如果确认数据不会丢失，可以使用强制类型转换，强制转后，如果数据不合法，直接将多余数据丢弃
	所有byte short char 在参与运算的时候会自动提升为int参与运算；
	使用float是赋值需要特殊处理；
		方案一：强制转换
		方案二：在小数后加一个字母f
	声明整数时，编译器做了特殊处理，包括类型转换、复杂运算以及范围校验；
	float和任何整数运算结果都为float，同理double也一样
	
Day1016
1.格式化输出printf（字符串，参数）
  %d表示整数  %f表示浮点数  %s表示字符  %m.n:  m表示要显示的宽度  n表示要显示的小数位数
2.赋值运算
	+=  -=  *=  /=  %=    可以避免数据类型提升和转换  减少代码量
3.比较运算
	字符串比较  比较字典序，第一个字符谁大，谁就大，如果相等就比较下一个字符，如果所有字符相等就比较长度，长度相等就表示两个字符串相等
	instanceof   比较类型  str instanceof String
4.逻辑运算：
	&&   发现一个值为false，当前逻辑运算立即终止，后续操作无效。
	||   发现一个值为ture，当前逻辑运算立即终止，后续操作无效。
5.位运算
	对计算机中，真实存在的补码形式进行运算，这种运算方式叫为运算；同等情况下，位运算性能最好
		编码格式
		十进制        二进制         源码				反码            补码
		31				11111		0001 1111		 0001 1111		   0001 1111
		-31							1001 1111		 1110 0000		   1110 0001
		原码：当前数据的基本二进制表示
		反码：如果是负数，对原码取反，符号位不变
				如果是正数，不变
		补码：如果是负数，反码+1
				如果是正数，不变
		在计算机中，数据都以补码形式存在
		<<左移运算，
				将二进制补码向左移动，不足的位用0补齐；左移了n位等同于乘以n个2，以32位一个循环，移32位会回到原来的数据
		>>右移运算，	
				正数：将二进制补码向右移动,左边用0补齐；左移了n位等同于除以n个2，以32位一个循，移32位会回到原来的数据
				负数：右移n位，左边用1补齐
		>>>无符号右移
			无符号右移n位，左边多出部分，补0，不论正负
		&按位与运算
			数据的每一位进行&运算，如果有一个为0，则结果为0；如果都为1，则结果为1
		|按位或运算
			数据的每一位进行|运算，如果有一位为1，结果为1；如果都为0，则结果为0
		^异或运算
			数据的每一位进行^运算，相同为0，不同为1；
		~按位取反
			数据的每一位取反，原来是1，结果为0，原来是0，结果为1.


Day1017
	1.标准输出system.out
	  标注输入 system.in     
	  Scanner  解析数据的工具   new Scanner（system.in）创建一个用于解析用户标注输入的工具
	  Scanner scanner=new Scanner（System.in）  创建一个引用类型变量scanner来存放new的工具。
	2.如果代码中出现常量，尽可能将常量提取出来，放在常量或变量中
	3.if_else   switch
		相同点：都用来做分支条件的判断
		不同点：if_else支持多种条件的判断    switch只支持一种条件判断，只有等于不支持范围的判断
	4.Random random=new Random（）；获取随机数；
	  int num=random.nextInt（1）；限制随机数范围。
	5.声明变量的作用域在本身的{}内，超过本身{}作用域无效
	6.关键字
		break：终止循环
		continue：直接进入下一次循环，continue后面的语句不执行；
	7.循环嵌套
			（1）先执行外层循环一次，然后完成全部的内层循环以后，才能继续进行下一次外层循环
			（2）循环过程中，依然可以使用break continue，此时break continue作用域最近的一层循环


Day1018
	1.数组：
		概念：一组相同类型数据的集合
		语法：int[] score=new int[3];
				int代表数组存储的数据类型
				[] 当前声明的变量是数组类型
				score  数组名
				int[] score声明了一个数组
				数组的空间在new的时候已经分配好了
				使用数组时，下标超过了最大范围，运行时会出现数组下标越界的错误。
				使用时必须先创建后使用，如果没有创建直接使用，会出现空指针异常
				使用数组前先判断数组是否为空
	2.JVM 内存模型
		PC寄存器：程序将要执行的下一条指令的位置
		方法区： 所有class
		本地方法区： 和操作系统相关的的内存模型
		虚拟机栈： 存储所有的栈帧，将每一执行的方法，封装成栈帧，放到栈中
			        栈帧中包括了当前方法所拥有的所有的变量（局部变量表），以及用于进行计算的空间（方法栈
					基本数据类型存储在栈中
					引用数据类型，栈中不存内容，只存储对应的引用
		虚拟机堆：	存储程序运行过程中所有复杂数据，包括数组，
					引用数据类型全部存储在堆中


Day1021
	1.方法：定义在类中，具有独立功能的代码段
			语法规则： 方法访问修饰符 方法返回值 方法名称（方法执行需要的参数列表）{
			方法执行的代码块
			}
			方法访问修饰符：控制方法的访问规则
			方法返回值：指定当前方法结束之后，需要返回给调用者什么类型的值
						如果不返回任何值，使用void
						如果有返回值，必须指定返回值的数据类型而不是void
			方法名称：必须符合标识符命名规范
			参数：按照变量声明的语法规则，来确定，方法执行必须有那些参数
					数据类型 变量名
			方法执行的代码块：每一次调用方法时，需要执行的代码全部写在带码块中
	调用方法：直接使用方法名即可调用定义好的方法
				注意：
				     （1）使用方法时，参数类型和参数个数，必须和定义时，定义的参数类型和参数个数相匹配
					 （2）类中方法的使用和顺序无关
					 （3）方法只能定义在类中
					 （4）多个参数用 ， 隔开 
	return：设置将要把什么样的数据类型返回给调用者
			如果返回类型不是void return必须写
			调用方法时，如果存在返回值，可以声明一个相同类型的变量，将其存储在变量中，以便以后使用
			如果方法没有返回值，不可进行赋值  如果写了return，后面不要跟任何返回值
			每一次执行到return，方法执行完成，立即退出当前方法，如果还有代码没执行，直接忽略
	方法储存机制：方法储存在栈帧中
					（1）将方法压栈
					（2）压栈过程中，如果有参数的传递，将参数的值做一份拷贝
					（3）如果在压栈方法中，对参数值进行了改变，是改变的当前方法独有的变量，不影响外部变量的值
					（4）当方法执行完成时，将栈帧从栈中弹出，回到调用所在的栈中
	
	方法的重载：
				java允许有相同的方法名，但是参数列表不同的方法同时存在
				为面向对象多态奠定了基础
				注意：
					（1）方法的重载，只和方法名和参数类型有关，和返回值类型无关，和访问修饰符无关，和参数名无关
					（2）方法被调用时，系统会根据参数类型去匹配应该执行拿一个方法，优先选择更加接近于实际类型的方法调用
					（3）参数类型可以部分相同，不能完全相同
					（4）如果有一个参数不能匹配，会直接报错
				int...声明当前参数类型为int类型的数组，并且数组的长度，有参数动态决定
	递归：方法调用自身实现代码的递归，是代码循环利用
		使用递归时，必须给给递归一个结束条件，不然导致栈溢出


Day1023
面向对象
	类的加载过程：
		（1）new关键字向jvm申请内存，jvm从方法区中找到对应的字节码信息，根据类中定义的成员变量
		  在对内存中开辟相应的空间。并对每个属性进行默认初始化 
		 （2）jvm对创建好的对象属性进行完默认初始化之后，执行构造方法中的内存，构造方法里面对对
		    象的属性进行必要的显示初始化，这个时候对象的初始化就完成了，有关键字new将初始化完成
			的对象的地址带回并赋值给对象的变量
	概念：区别于面向过程而言，开发者从程序的开发者变成指挥者，
		  编写程序的时候如果需要一个功能，不再首先思考该功能该怎么实现，
	      而是去寻找有没有人已经帮我们实现了，如果已经实现了，直接调用，
	      如果没有自己从头实现该功能，并作出封装以便以后使用
	好处：（1）将复杂问题进行简单化
		  （2）更加符合人的思维
		  （3）程序员更多的时间可以花在设计架构上
	类与对象的区别：
		类：对一类对象的抽象描述，用来描述事物的，事物存在很多属性和行为，一个类里面填写该类事物描述的属性和行为
		对象：根据类所描述创建出来的
	成员变量和局部变量的区别：
		（1）定义位置不同，局部变量定义在方法中，成员变量定义在类体中、方法外定义
		（2）局部变量必须显示初始化才能使用，成员变量可以只声明不赋值，jvm会对其默认初始化
			 当然也可以初始化
		（3）局部变量的作用域在所在的方法中，成员变量的作用域是整个类的方法中
		（4）被访问的优先级不同。如果成员变量和局部变量同名，局部变量被访问的优先级高于成员变量（就近原则）。
		（5）局部变量的内存在栈中，成员变量的内存在对象中，没创建一个对象就会被分配一次
		（6）生命周期不同，当方法结束时候，方法在栈中分配的所有局部变量的内存会被回收。而成员变量的生命周期依赖于所在的对象，对象被回收了，对象的属性一并被回收了
		
	类的成员变量：用来描述当前事物的属性
		语法格式：访问修饰符 变量的类型 变量的名称
		注意：（1）成员变量的声明通常放在类的最开始
			  （2）多个成员变量分开写
			  （3）成员变量和局部变量的区别
					成员变量定义在类里面，局部变量定义在方法中
					成员变量分配在堆空间中，局部变量分配在栈空间中
					成员变量在对象创建的时候，如果没有给初始值，会默认分配值
					int为0 double为0.0 引用类型为null；局部变量在声明是必须先赋值再使用
					局部变量会随着方法出栈而销毁
					成员变量如果丢失引用地址，不会立即销毁，会等待jvm垃圾的回收机制去判断内存空间是否应该被回收，不需要用户考虑 
	类的成员方法：
		类的成员方法，用来描述当前事物的行为
		语法格式：和方法格式一样访问修饰符
			      访问修饰符 方法返回值 方法名（参数列表）{ 
				  }	
	成员变量和成员方法有静态和非静态之分
	匿名对象：
		创建的对象只需使用一次，不将该对象赋值给声明的变量
		好处：（1）对象只能使用一次，不会进行多次使用
			  （2）依然可以进行参数传递
		直接使用new关键之创建对象，使用 . 运算符执行属性和方法
	对象也能在方法中作为参数传递  public static void print（Person person）{}
封装：将重要的细节隐藏掉，提供公共的方法来处理
	优点：
		（1）提高了安全性
		（2）提高了代码重用性
		（3）隔离性
	关键字private：访问修饰符 私有的
		被私有化的成员变量只能在本类中使用，实例化对象不能调用
	设计模式：
		封装一个用户对象，推荐采用javabean的形式进行封装
		（1）所有属性全部私有
		（2）为每一个属性写一个get方法；以便使用者获取该项值
		（3）为每一个属性写一个set方法，以便使用者设置该项值

Day1024
	构造方法（函数）：每一次创建一个对象都会调用一个构造方法
		语法：访问修饰符 构造方法名（参数列表）{}
		注意：（1）构造方法名必须和类名相同
			  （2）每一个类默认存在一个无参数的无方法内容的空白的构造方法
					如果自己定义了，会覆盖默认的构造方法
			  （3）构造方法没有返回值，
			  （4）构造方法可以有方法体 构造方法中可以使用成员变量和成员方法，成员方法不可以调用构造方法
			  （5）构造方法可以传参数，通常用来给成员变量赋初始值
			  （6）构造方法可进行方法重载
			  （7）构造方法可以私有，私有构造方法只能在类里面使用
	this关键字：
		代表当前对象的引用
		使用范围：在构造方法和成员方法中使用，在构造方法中代表刚刚创建好的对象，在成员方法中代表调用该方法的对象
		作用：（1）保证了不同对象调用同一个方法，访问的是不同对象的内部属性
			  （2）当局部变量和成员变量同名，使用this来区分，this后面跟的是本类的成员
			  （3）在本类的构造方法内调用本类的其他构造方法this（参数列表）必须放在第一局
		
		在类本身中使用自己本身的成员，this默认存在可以省略
		如果类的成员变量和局部变量冲突了，强制写上this
	static关键字：设置静态成员，包括成员变量和成员方法
		入口方法必须加static	
		使用了static修饰的成员方法叫做静态成员方法
		使用了static修饰的成员变量叫做静态成员变量
		成员变量和静态成员变量的区别：
			相同点：
			（1）创建的对象，成员变量和静态成员变量都可以赋值和取值
			（2）都可以使用所有的访问修饰符和数据类型
			不同点：静态成员变量储存在方法区中
			（1）静态成员变量的使用不依赖于对象,在对象还没有被创建时就可以使用，可以直接使用类名操作变量，在类中使用  Person.sex
			（2）静态成员变量，不存放在对象中
			（3）被所有类的实例共享
		静态成员方法和成员方法的区别
			相同点：
			（1）创建的对象，既可以使用成员方法，也可以使用静态成员方法
			（2）都严格符合方法的语法声明定义
			不同点：
			（1）静态成员方法不需要创建对象就可以使用，可以直接使用类名来操作静态成员方法
			（2）静态成员方法只能访问静态成员
			     成员方法可以访问所有的静态成员包括成员变量和方法
			（3）静态方法中不能写this  和  super	 
	代码块 {}在类里面组织一段代码，可以存放在类中的任意位置，＊＊这段代码在创造对象时，优先于构造方法执行
	静态代码块static｛｝　只能调用静态成员，只会在第一次装载的时候执行一次
	

Day1025
	继承：多个类中相同的属性和行为，进行抽象和提取，提到另一个类中，当前这些类补需要重复编写这部分代码
		  而是通过extends关键字继承提取出来的类
		  A extends B 代表A继承B   A叫做子类B叫做父类
		  子类可以使用父类的非私有属性、方法，
		  子类如果想要使用私有属性必须是有设置的共有方法设置
		  extends推荐A是B
		  java只支持单继承，一个类只能存在一个父类
		  java支持继承的传递 ，A extends B，B extends C，->A extend  C;
		  在传递继承中子类可以访问父类以上的非私有属性和方法
		  父类不可以访问子类的属性和方法
		  优点：
			（1）提升了代码的复用性
			（2）类与类之间不再是单纯的调用关系，为多态产生了前提
		方法重写：如果子类中出现了和父类一模一样的方法，会直接覆盖掉父类的方法
			前提：（1）和父类的方法一模一样
				  （2）方法不能改变原有父类的返回值
				  （3）访问修饰符范围不能比父类小
				  （4）父类的私有方法不能被重写
				  （5）@Override 注解，用来标记当前方法重写了父类方法，推荐每一个重写方法都加上
				  （6）父类的静态方法在子类只能使用静态方法覆盖，并且不能使用@Override标记
		关键字super：代表当前对象父类内存空间的标识符，this当前对象标识符
			（1）this使用子类非私有的成员变量
			     super使用父类非私有的成员变量
			（2）this使用子类非私有的成员方法
			     super使用父类的非私有成员方法
			（3）super（）可以在子类的构造方法中调用父类的构造方法
							（1）如果没有指定调用父类的哪一个构造方法，默认使用super（）调用无参构造方法
							（2）在构造方法中super（参数列表）必须放在第一行，确认当前执行子类代码时，父类构造方法已经调用完成
				this（参数列表）可以调用本类中其他的构造方法
					（1）子类进行this（参数列表）调用自己的构造方法的时候，父类构造方法只会调用一次，不会重复调用
					（2）super（参数列表）和this（参数列表）只能二选一
		子类的实例化流程：先装载父类，后装载子类，按照静态代码块-代码块-构造方法   顺序执行
		final修饰符： 
			修饰变量的时候，该变量为常量
				（1）不可被修改
				（2）必须给初始值
			修饰成员方法，该方法不能被重写
			final修饰类，当前类不能被继承
			
			
Day1028
	在继承关系中，如果对子类编写构造方法
		注意专属于子类的属性直接等号赋值，父类的属性调用super（参数列表）
		
	排序工具Arrrays.sort（a，b）
		a传入要排序的数组
		b传入比较规则
			（1）new Comparator
			（2）将泛型T字母，修改为真实的对象class
			（3）重写此规则，重写compara方法
					返回值>0,第一个对象大于第二对象
	
	抽象类：在一个类中，可以存在只有方法名和参数、没有方法体的方法，该方法具体实现细节强制要求子类完成，这种方法叫抽象方法，包含抽象方法的类叫抽象类
			（1）使用abstract关键字来定义抽象方法和类
			（2）只要类中存在一个抽象方法，该类必须定义为抽象类
			（3）抽象类中可以存在正常方法，不一定全是抽象方法
			（4）一旦一个类被定义为抽象类，该类不能使用new关键字实例化对象
			（5）所有抽象方法必须被实现，如果子类没有实现父类的抽象方法，必须将子类定义为抽象方法，再由子类的子类去实现抽象方法
	
	Object类：java所有类的祖先


Day1029
	接口：为了实现多继承的
	      接口是一种特殊的抽象类，原则上只提供不可变的静态变量和抽象方法
			（1）使用interfa关键字定义接口，访问修饰符一般使用public
				 语法规则：
					访问修师符 interface 接口名{}
			（2）接口中原则上，所有的方法都推荐使用抽象方法，不编写方法体
			（3）接口的方法中，原则上只支持且自带 public abstract修饰符
			（4）使用implements关键字，可以是一个类实现接口，实现了接口的类，要么实现接口中的所有抽象方法。要么变成抽象类
			（5）一个类可以实现多个接口，实现了类似于多继承的概念
			（6）成员变量自带public static final访问修饰符 不可以用其他访问修饰符，所有实现了接口的类都共享同一份常量
			（7）如果使用了default关键字修饰接口中的抽象方法可以有方法体，该方法不再是抽象方法成为普通方法
			（8）使用static关键字修饰的方法，子类对象无法使用静态方法
			（9）接口与接口之间可以实现继承，在不改变接口原有的功能的前提下，实现对接口的继承

	多态：与成员变量无关
		  通过父类的引用，指向了对内存空间中的子类，每一次使用该引用时，
	      如果成员方法重写了父类的方法在调用时以重写过后的方法为准
		  如果是成员变量没有被重写，在调用时，使用父类的方法
		  如果父类想使用子类的成员变量，编译时会报错，   必须先进行强制类型转换
		  
		  如果两个类存在A extends B，可以通过多态，对父类进行强制类型转换为子类
		  
		  总结：父类有的才能用，父类没有的不能用，父类子类都有，方法以重写为主，成员变量只使用父类得到
		  
		  基于接口实现多态
			语法格式：
				接口名 变量名=new 实例类名
				（1）只能访问接口中已经定义好的方法
				（2）只能访问接口中已经定义好的变量
				（3）如果想使用类特有的方法和变量，需要进行强转
			强转必须满足接口的实现和多态

Day1030
	内部类：将一个类写在另外一个类的作用域中，这种写法叫普通内部类
		创建内部类：
			（1）创建外部类实例（如果已经有了就不用了我），使用 . 运算符根据外部类的实例来创建内部类
				在外部类的普通成员方法中可以直接使用new关键字来创建内部类
					Inner inner=new Outah（）.nwe Inner();
			（2）内部类可以正常使用普通方法、构造、变量和代码块
			（3）外部类不可以使用内部类的普通成员变量，内部类可以使用外部类的普通成员变量（包括私有的）
			
			静态内部类：如果在内部类中使用了静态方法那么当前的内部类必须添加static的访问修饰符
				（1）使用类名可以直接调用静态内部类中的静态方法，
				     在外部类外，需要同时使用外部类类名.内部类类名
				     在外部类中调用，直接使用内部类类名
				（2）如果要对静态内部类进行实例化，不再是先创建外部类实例，再创造内部类实例；而是，直接通过类名找到静态内部类的class，直接实例化
				（3）静态内部类的静态方法方法，可以使用静态内部类和外部类的静态变量（包括私有的）
				（4）静态内部类的变量，可以声明为静态变量，不一定是常量
			
			局部内部类：将类写在方法中。
				 （1）实例化只能在该方法中进行，而且类声明完成以后
				 （2）局部内部类的变量使用  调用外部类的成员变量需要  外部类类名.this.变量名